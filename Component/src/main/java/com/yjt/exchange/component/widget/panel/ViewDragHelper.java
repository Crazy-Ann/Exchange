package com.hynet.heebit.components.widget.panel;import android.content.Context;import android.view.MotionEvent;import android.view.VelocityTracker;import android.view.View;import android.view.ViewConfiguration;import android.view.ViewGroup;import android.view.animation.Interpolator;import java.util.Arrays;import androidx.core.view.MotionEventCompat;import androidx.core.view.VelocityTrackerCompat;import androidx.core.view.ViewCompat;import androidx.core.widget.ScrollerCompat;public class ViewDragHelper {    private static final int INVALID_POINTER = -1;    public static final int STATE_IDLE = 0;    private static final int STATE_DRAGGING = 1;    private static final int STATE_SETTLING = 2;    private static final int EDGE_LEFT = 1 << 0;    private static final int EDGE_RIGHT = 1 << 1;    private static final int EDGE_TOP = 1 << 2;    private static final int EDGE_BOTTOM = 1 << 3;    private static final int EDGE_ALL = EDGE_LEFT | EDGE_TOP | EDGE_RIGHT | EDGE_BOTTOM;    private static final int DIRECTION_HORIZONTAL = 1 << 0;    private static final int DIRECTION_VERTICAL = 1 << 1;    private static final int DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;    private static final int EDGE_SIZE = 20; // dp    private static final int BASE_SETTLE_DURATION = 256; // ms    private static final int MAX_SETTLE_DURATION = 600; // ms    private int dragState;    private int touchSlop;    private int activePointerId = INVALID_POINTER;    private float[] initialMotionX;    private float[] initialMotionY;    private float[] lastMotionX;    private float[] lastMotionY;    private int[] initialEdgesTouched;    private int[] edgeDragsInProgress;    private int[] edgeDragsLocked;    private int pointersDown;    private VelocityTracker velocityTracker;    private float maxVelocity;    private float minVelocity;    private int edgeSize;    private int trackingEdges;    private ScrollerCompat scrollerCompat;    private final Callback callback;    private View capturedView;    private boolean releaseInProgress;    private final ViewGroup viewGroup;    public static abstract class Callback {        public void onViewDragStateChanged(int state) {}        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {}        public void onViewCaptured(View capturedChild, int activePointerId) {}        public void onViewReleased(View releasedChild, float xvel, float yvel) {}        public void onEdgeTouched(int edgeFlags, int pointerId) {}        public boolean onEdgeLock(int edgeFlags) {            return false;        }        public void onEdgeDragStarted(int edgeFlags, int pointerId) {}        public int getOrderedChildIndex(int index) {            return index;        }        public int getViewHorizontalDragRange(View child) {            return 0;        }        public int getViewVerticalDragRange(View child) {            return 0;        }        public abstract boolean tryCaptureView(View child, int pointerId);        public int clampViewPositionHorizontal(View child, int left, int dx) {            return 0;        }        public int clampViewPositionVertical(View child, int top, int dy) {            return 0;        }    }    private static final Interpolator sInterpolator = new Interpolator() {        public float getInterpolation(float t) {            t -= 1.0f;            return t * t * t * t * t + 1.0f;        }    };    private final Runnable runnable = new Runnable() {        public void run() {            setDragState(STATE_IDLE);        }    };    public static ViewDragHelper create(ViewGroup forParent, Callback cb) {        return new ViewDragHelper(forParent.getContext(), forParent, null, cb);    }    public static ViewDragHelper create(ViewGroup forParent, Interpolator interpolator, Callback cb) {        return new ViewDragHelper(forParent.getContext(), forParent, interpolator, cb);    }    public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {        final ViewDragHelper helper = create(forParent, cb);        helper.touchSlop = (int) (helper.touchSlop * (1 / sensitivity));        return helper;    }    public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Interpolator interpolator, Callback cb) {        final ViewDragHelper helper = create(forParent, interpolator, cb);        helper.touchSlop = (int) (helper.touchSlop * (1 / sensitivity));        return helper;    }    private ViewDragHelper(Context context, ViewGroup viewGroup, Interpolator interpolator, Callback callback) {        if (viewGroup == null) {            throw new IllegalArgumentException("Parent view may not be null");        }        if (callback == null) {            throw new IllegalArgumentException("Callback may not be null");        }        this.viewGroup = viewGroup;        this.callback = callback;        final ViewConfiguration viewConfiguration = ViewConfiguration.get(context);        final float density = context.getResources().getDisplayMetrics().density;        this.edgeSize = (int) (EDGE_SIZE * density + 0.5f);        this.touchSlop = viewConfiguration.getScaledTouchSlop();        this.maxVelocity = viewConfiguration.getScaledMaximumFlingVelocity();        this.minVelocity = viewConfiguration.getScaledMinimumFlingVelocity();        this.scrollerCompat = ScrollerCompat.create(context, interpolator != null ? interpolator : sInterpolator);    }    public void setMinVelocity(float minVel) {        minVelocity = minVel;    }    public float getMinVelocity() {        return minVelocity;    }    public int getViewDragState() {        return dragState;    }    public void setEdgeTrackingEnabled(int edgeFlags) {        trackingEdges = edgeFlags;    }    public int getEdgeSize() {        return edgeSize;    }    public void captureChildView(View childView, int activePointerId) {        if (childView.getParent() != viewGroup) {            throw new IllegalArgumentException("captureChildView: parameter must be a descendant of the ViewDragHelper's tracked parent view (" + viewGroup + ")");        }        this.capturedView = childView;        this.activePointerId = activePointerId;        this.callback.onViewCaptured(childView, activePointerId);        setDragState(STATE_DRAGGING);    }    public View getCapturedView() {        return capturedView;    }    public int getActivePointerId() {        return activePointerId;    }    public int getTouchSlop() {        return touchSlop;    }    public void cancel() {        this.activePointerId = INVALID_POINTER;        clearMotionHistory();        if (velocityTracker != null) {            velocityTracker.recycle();            velocityTracker = null;        }    }    public void abort() {        cancel();        if (dragState == STATE_SETTLING) {            final int oldX = scrollerCompat.getCurrX();            final int oldY = scrollerCompat.getCurrY();            scrollerCompat.abortAnimation();            final int newX = scrollerCompat.getCurrX();            final int newY = scrollerCompat.getCurrY();            callback.onViewPositionChanged(capturedView, newX, newY, newX - oldX, newY - oldY);        }        setDragState(STATE_IDLE);    }    public boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {        capturedView = child;        activePointerId = INVALID_POINTER;        return forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);    }    public boolean settleCapturedViewAt(int finalLeft, int finalTop) {        if (!releaseInProgress) {            throw new IllegalStateException("Cannot settleCapturedViewAt outside of a call to Callback#onViewReleased");        }        return forceSettleCapturedViewAt(finalLeft, finalTop,                                         (int) VelocityTrackerCompat.getXVelocity(velocityTracker, activePointerId),                                         (int) VelocityTrackerCompat.getYVelocity(velocityTracker, activePointerId));    }    private boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {        final int startLeft = capturedView.getLeft();        final int startTop = capturedView.getTop();        final int dx = finalLeft - startLeft;        final int dy = finalTop - startTop;        if (dx == 0 && dy == 0) {            // Nothing to do. Send callbacks, be done.            scrollerCompat.abortAnimation();            setDragState(STATE_IDLE);            return false;        }        final int duration = computeSettleDuration(capturedView, dx, dy, xvel, yvel);        scrollerCompat.startScroll(startLeft, startTop, dx, dy, duration);        setDragState(STATE_SETTLING);        return true;    }    private int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {        xvel = clampMag(xvel, (int) minVelocity, (int) maxVelocity);        yvel = clampMag(yvel, (int) minVelocity, (int) maxVelocity);        final int absDx = Math.abs(dx);        final int absDy = Math.abs(dy);        final int absXVel = Math.abs(xvel);        final int absYVel = Math.abs(yvel);        final int addedVel = absXVel + absYVel;        final int addedDistance = absDx + absDy;        final float xweight = xvel != 0 ? (float) absXVel / addedVel : (float) absDx / addedDistance;        final float yweight = yvel != 0 ? (float) absYVel / addedVel : (float) absDy / addedDistance;        int xduration = computeAxisDuration(dx, xvel, callback.getViewHorizontalDragRange(child));        int yduration = computeAxisDuration(dy, yvel, callback.getViewVerticalDragRange(child));        return (int) (xduration * xweight + yduration * yweight);    }    private int computeAxisDuration(int delta, int velocity, int motionRange) {        if (delta == 0) {            return 0;        }        final int width = viewGroup.getWidth();        final int halfWidth = width / 2;        final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);        final float distance = halfWidth + halfWidth * distanceInfluenceForSnapDuration(distanceRatio);        int duration;        velocity = Math.abs(velocity);        if (velocity > 0) {            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));        } else {            final float range = (float) Math.abs(delta) / motionRange;            duration = (int) ((range + 1) * BASE_SETTLE_DURATION);        }        return Math.min(duration, MAX_SETTLE_DURATION);    }    private int clampMag(int value, int absMin, int absMax) {        final int absValue = Math.abs(value);        if (absValue < absMin) return 0;        if (absValue > absMax) return value > 0 ? absMax : -absMax;        return value;    }    private float clampMag(float value, float absMin, float absMax) {        final float absValue = Math.abs(value);        if (absValue < absMin) return 0;        if (absValue > absMax) return value > 0 ? absMax : -absMax;        return value;    }    private float distanceInfluenceForSnapDuration(float f) {        f -= 0.5f; // center the values about 0.        f *= 0.3f * Math.PI / 2.0f;        return (float) Math.sin(f);    }    public void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {        if (!releaseInProgress) {            throw new IllegalStateException("Cannot flingCapturedView outside of a call to Callback#onViewReleased");        }        scrollerCompat.fling(capturedView.getLeft(), capturedView.getTop(),                             (int) VelocityTrackerCompat.getXVelocity(velocityTracker, activePointerId),                             (int) VelocityTrackerCompat.getYVelocity(velocityTracker, activePointerId),                             minLeft, maxLeft, minTop, maxTop);        setDragState(STATE_SETTLING);    }    public boolean continueSettling(boolean deferCallbacks) {        // Make sure, there is a captured view        if (capturedView == null) {            return false;        }        if (dragState == STATE_SETTLING) {            boolean keepGoing = scrollerCompat.computeScrollOffset();            final int x = scrollerCompat.getCurrX();            final int y = scrollerCompat.getCurrY();            final int dx = x - capturedView.getLeft();            final int dy = y - capturedView.getTop();            if (!keepGoing && dy != 0) { //fix #525                //Invalid drag state                capturedView.setTop(0);                return true;            }            if (dx != 0) {                capturedView.offsetLeftAndRight(dx);            }            if (dy != 0) {                capturedView.offsetTopAndBottom(dy);            }            if (dx != 0 || dy != 0) {                callback.onViewPositionChanged(capturedView, x, y, dx, dy);            }            if (keepGoing && x == scrollerCompat.getFinalX() && y == scrollerCompat.getFinalY()) {                // Close enough. The interpolator/scroller might think we're still moving                // but the user sure doesn't.                scrollerCompat.abortAnimation();                keepGoing = scrollerCompat.isFinished();            }            if (!keepGoing) {                if (deferCallbacks) {                    viewGroup.post(runnable);                } else {                    setDragState(STATE_IDLE);                }            }        }        return dragState == STATE_SETTLING;    }    private void dispatchViewReleased(float xvel, float yvel) {        releaseInProgress = true;        callback.onViewReleased(capturedView, xvel, yvel);        releaseInProgress = false;        if (dragState == STATE_DRAGGING) {            // onViewReleased didn't call a method that would have changed this. Go idle.            setDragState(STATE_IDLE);        }    }    private void clearMotionHistory() {        if (initialMotionX == null) {            return;        }        Arrays.fill(initialMotionX, 0);        Arrays.fill(initialMotionY, 0);        Arrays.fill(lastMotionX, 0);        Arrays.fill(lastMotionY, 0);        Arrays.fill(initialEdgesTouched, 0);        Arrays.fill(edgeDragsInProgress, 0);        Arrays.fill(edgeDragsLocked, 0);        pointersDown = 0;    }    private void clearMotionHistory(int pointerId) {        if (initialMotionX == null || initialMotionX.length <= pointerId) {            return;        }        initialMotionX[pointerId] = 0;        initialMotionY[pointerId] = 0;        lastMotionX[pointerId] = 0;        lastMotionY[pointerId] = 0;        initialEdgesTouched[pointerId] = 0;        edgeDragsInProgress[pointerId] = 0;        edgeDragsLocked[pointerId] = 0;        pointersDown &= ~(1 << pointerId);    }    private void ensureMotionHistorySizeForId(int pointerId) {        if (initialMotionX == null || initialMotionX.length <= pointerId) {            float[] imx = new float[pointerId + 1];            float[] imy = new float[pointerId + 1];            float[] lmx = new float[pointerId + 1];            float[] lmy = new float[pointerId + 1];            int[] iit = new int[pointerId + 1];            int[] edip = new int[pointerId + 1];            int[] edl = new int[pointerId + 1];            if (initialMotionX != null) {                System.arraycopy(initialMotionX, 0, imx, 0, initialMotionX.length);                System.arraycopy(initialMotionY, 0, imy, 0, initialMotionY.length);                System.arraycopy(lastMotionX, 0, lmx, 0, lastMotionX.length);                System.arraycopy(lastMotionY, 0, lmy, 0, lastMotionY.length);                System.arraycopy(initialEdgesTouched, 0, iit, 0, initialEdgesTouched.length);                System.arraycopy(edgeDragsInProgress, 0, edip, 0, edgeDragsInProgress.length);                System.arraycopy(edgeDragsLocked, 0, edl, 0, edgeDragsLocked.length);            }            this.initialMotionX = imx;            this.initialMotionY = imy;            this.lastMotionX = lmx;            this.lastMotionY = lmy;            this.initialEdgesTouched = iit;            this.edgeDragsInProgress = edip;            this.edgeDragsLocked = edl;        }    }    private void saveInitialMotion(float x, float y, int pointerId) {        ensureMotionHistorySizeForId(pointerId);        this.initialMotionX[pointerId] = lastMotionX[pointerId] = x;        this.initialMotionY[pointerId] = lastMotionY[pointerId] = y;        this.initialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y);        this.pointersDown |= 1 << pointerId;    }    private void saveLastMotion(MotionEvent ev) {        final int pointerCount = MotionEventCompat.getPointerCount(ev);        for (int i = 0; i < pointerCount; i++) {            final int pointerId = MotionEventCompat.getPointerId(ev, i);            final float x = MotionEventCompat.getX(ev, i);            final float y = MotionEventCompat.getY(ev, i);            if (lastMotionX != null && lastMotionY != null && lastMotionX.length > pointerId && lastMotionY.length > pointerId) {                this.lastMotionX[pointerId] = x;                this.lastMotionY[pointerId] = y;            }        }    }    public boolean isPointerDown(int pointerId) {        return (pointersDown & 1 << pointerId) != 0;    }    void setDragState(int state) {        if (this.dragState != state) {            this.dragState = state;            callback.onViewDragStateChanged(state);            if (this.dragState == STATE_IDLE) {                this.capturedView = null;            }        }    }    boolean tryCaptureViewForDrag(View toCapture, int pointerId) {        if (toCapture == capturedView && activePointerId == pointerId) {            return true;        }        if (toCapture != null && callback.tryCaptureView(toCapture, pointerId)) {            this.activePointerId = pointerId;            captureChildView(toCapture, pointerId);            return true;        }        return false;    }    protected boolean canScroll(View v, boolean checkV, int dx, int dy, int x, int y) {        if (v instanceof ViewGroup) {            final ViewGroup group = (ViewGroup) v;            final int scrollX = v.getScrollX();            final int scrollY = v.getScrollY();            final int count = group.getChildCount();            for (int i = count - 1; i >= 0; i--) {                final View child = group.getChildAt(i);                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {                    return true;                }            }        }        return checkV && (ViewCompat.canScrollHorizontally(v, -dx) || ViewCompat.canScrollVertically(v, -dy));    }    public boolean shouldInterceptTouchEvent(MotionEvent ev) {        final int action = MotionEventCompat.getActionMasked(ev);        final int actionIndex = MotionEventCompat.getActionIndex(ev);        if (action == MotionEvent.ACTION_DOWN) {            cancel();        }        if (velocityTracker == null) {            this.velocityTracker = VelocityTracker.obtain();        }        velocityTracker.addMovement(ev);        switch (action) {            case MotionEvent.ACTION_DOWN: {                final float x = ev.getX();                final float y = ev.getY();                final int pointerId = MotionEventCompat.getPointerId(ev, 0);                saveInitialMotion(x, y, pointerId);                final View toCapture = findTopChildUnder((int) x, (int) y);                if (toCapture == capturedView && dragState == STATE_SETTLING) {                    tryCaptureViewForDrag(toCapture, pointerId);                }                final int edgesTouched = initialEdgesTouched[pointerId];                if ((edgesTouched & trackingEdges) != 0) {                    callback.onEdgeTouched(edgesTouched & trackingEdges, pointerId);                }                break;            }            case MotionEventCompat.ACTION_POINTER_DOWN: {                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);                final float x = MotionEventCompat.getX(ev, actionIndex);                final float y = MotionEventCompat.getY(ev, actionIndex);                saveInitialMotion(x, y, pointerId);                if (this.dragState == STATE_IDLE) {                    final int edgesTouched = initialEdgesTouched[pointerId];                    if ((edgesTouched & trackingEdges) != 0) {                        callback.onEdgeTouched(edgesTouched & trackingEdges, pointerId);                    }                } else if (this.dragState == STATE_SETTLING) {                    final View toCapture = findTopChildUnder((int) x, (int) y);                    if (toCapture == capturedView) {                        tryCaptureViewForDrag(toCapture, pointerId);                    }                }                break;            }            case MotionEvent.ACTION_MOVE: {                // First to cross a touch slop over a draggable view wins. Also report edge drags.                final int pointerCount = MotionEventCompat.getPointerCount(ev);                for (int i = 0; i < pointerCount && initialMotionX != null && initialMotionY != null; i++) {                    final int pointerId = MotionEventCompat.getPointerId(ev, i);                    if (pointerId >= initialMotionX.length || pointerId >= initialMotionY.length) {                        continue;                    }                    final float x = MotionEventCompat.getX(ev, i);                    final float y = MotionEventCompat.getY(ev, i);                    final float dx = x - initialMotionX[pointerId];                    final float dy = y - initialMotionY[pointerId];                    reportNewEdgeDrags(dx, dy, pointerId);                    if (this.dragState == STATE_DRAGGING) {                        // Callback might have started an edge drag                        break;                    }                    final View toCapture = findTopChildUnder((int) initialMotionX[pointerId], (int) initialMotionY[pointerId]);                    if (toCapture != null && checkTouchSlop(toCapture, dx, dy) && tryCaptureViewForDrag(toCapture, pointerId)) {                        break;                    }                }                saveLastMotion(ev);                break;            }            case MotionEventCompat.ACTION_POINTER_UP: {                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);                clearMotionHistory(pointerId);                break;            }            case MotionEvent.ACTION_UP:            case MotionEvent.ACTION_CANCEL: {                cancel();                break;            }        }        return dragState == STATE_DRAGGING;    }    public void processTouchEvent(MotionEvent ev) {        final int action = MotionEventCompat.getActionMasked(ev);        final int actionIndex = MotionEventCompat.getActionIndex(ev);        if (action == MotionEvent.ACTION_DOWN) {            cancel();        }        if (this.velocityTracker == null) {            this.velocityTracker = VelocityTracker.obtain();        }        velocityTracker.addMovement(ev);        switch (action) {            case MotionEvent.ACTION_DOWN: {                final float x = ev.getX();                final float y = ev.getY();                final int pointerId = MotionEventCompat.getPointerId(ev, 0);                final View toCapture = findTopChildUnder((int) x, (int) y);                saveInitialMotion(x, y, pointerId);                tryCaptureViewForDrag(toCapture, pointerId);                final int edgesTouched = initialEdgesTouched[pointerId];                if ((edgesTouched & trackingEdges) != 0) {                    callback.onEdgeTouched(edgesTouched & trackingEdges, pointerId);                }                break;            }            case MotionEventCompat.ACTION_POINTER_DOWN: {                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);                final float x = MotionEventCompat.getX(ev, actionIndex);                final float y = MotionEventCompat.getY(ev, actionIndex);                saveInitialMotion(x, y, pointerId);                if (dragState == STATE_IDLE) {                    tryCaptureViewForDrag(findTopChildUnder((int) x, (int) y), pointerId);                    final int edgesTouched = initialEdgesTouched[pointerId];                    if ((edgesTouched & trackingEdges) != 0) {                        callback.onEdgeTouched(edgesTouched & trackingEdges, pointerId);                    }                } else if (isCapturedViewUnder((int) x, (int) y)) {                    tryCaptureViewForDrag(capturedView, pointerId);                }                break;            }            case MotionEvent.ACTION_MOVE: {                if (dragState == STATE_DRAGGING) {                    final int index = MotionEventCompat.findPointerIndex(ev, activePointerId);                    final float x = MotionEventCompat.getX(ev, index);                    final float y = MotionEventCompat.getY(ev, index);                    final int idx = (int) (x - lastMotionX[activePointerId]);                    final int idy = (int) (y - lastMotionY[activePointerId]);                    dragTo(capturedView.getLeft() + idx, capturedView.getTop() + idy, idx, idy);                    saveLastMotion(ev);                } else {                    final int pointerCount = MotionEventCompat.getPointerCount(ev);                    for (int i = 0; i < pointerCount; i++) {                        final int pointerId = MotionEventCompat.getPointerId(ev, i);                        final float x = MotionEventCompat.getX(ev, i);                        final float y = MotionEventCompat.getY(ev, i);                        final float dx = x - initialMotionX[pointerId];                        final float dy = y - initialMotionY[pointerId];                        reportNewEdgeDrags(dx, dy, pointerId);                        if (dragState == STATE_DRAGGING) {                            break;                        }                        final View toCapture = findTopChildUnder((int) initialMotionX[pointerId], (int) initialMotionY[pointerId]);                        if (checkTouchSlop(toCapture, dx, dy) &&                                tryCaptureViewForDrag(toCapture, pointerId)) {                            break;                        }                    }                    saveLastMotion(ev);                }                break;            }            case MotionEventCompat.ACTION_POINTER_UP: {                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);                if (dragState == STATE_DRAGGING && pointerId == activePointerId) {                    int newActivePointer = INVALID_POINTER;                    final int pointerCount = MotionEventCompat.getPointerCount(ev);                    for (int i = 0; i < pointerCount; i++) {                        final int id = MotionEventCompat.getPointerId(ev, i);                        if (id == activePointerId) {                            continue;                        }                        final float x = MotionEventCompat.getX(ev, i);                        final float y = MotionEventCompat.getY(ev, i);                        if (findTopChildUnder((int) x, (int) y) == capturedView && tryCaptureViewForDrag(capturedView, id)) {                            newActivePointer = activePointerId;                            break;                        }                    }                    if (newActivePointer == INVALID_POINTER) {                        releaseViewForPointerUp();                    }                }                clearMotionHistory(pointerId);                break;            }            case MotionEvent.ACTION_UP: {                if (dragState == STATE_DRAGGING) {                    releaseViewForPointerUp();                }                cancel();                break;            }            case MotionEvent.ACTION_CANCEL: {                if (dragState == STATE_DRAGGING) {                    dispatchViewReleased(0, 0);                }                cancel();                break;            }        }    }    private void reportNewEdgeDrags(float dx, float dy, int pointerId) {        int dragsStarted = 0;        if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) {            dragsStarted |= EDGE_LEFT;        }        if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) {            dragsStarted |= EDGE_TOP;        }        if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) {            dragsStarted |= EDGE_RIGHT;        }        if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) {            dragsStarted |= EDGE_BOTTOM;        }        if (dragsStarted != 0) {            edgeDragsInProgress[pointerId] |= dragsStarted;            callback.onEdgeDragStarted(dragsStarted, pointerId);        }    }    private boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge) {        final float absDelta = Math.abs(delta);        final float absODelta = Math.abs(odelta);        if ((initialEdgesTouched[pointerId] & edge) != edge || (trackingEdges & edge) == 0 || (edgeDragsLocked[pointerId] & edge) == edge || (edgeDragsInProgress[pointerId] & edge) == edge || (absDelta <= touchSlop && absODelta <= touchSlop)) {            return false;        }        if (absDelta < absODelta * 0.5f && callback.onEdgeLock(edge)) {            edgeDragsLocked[pointerId] |= edge;            return false;        }        return (edgeDragsInProgress[pointerId] & edge) == 0 && absDelta > touchSlop;    }    private boolean checkTouchSlop(View child, float dx, float dy) {        if (child == null) {            return false;        }        final boolean checkHorizontal = callback.getViewHorizontalDragRange(child) > 0;        final boolean checkVertical = callback.getViewVerticalDragRange(child) > 0;        if (checkHorizontal && checkVertical) {            return dx * dx + dy * dy > touchSlop * touchSlop;        } else if (checkHorizontal) {            return Math.abs(dx) > touchSlop;        } else if (checkVertical) {            return Math.abs(dy) > touchSlop;        }        return false;    }    public boolean checkTouchSlop(int directions) {        final int count = initialMotionX.length;        for (int i = 0; i < count; i++) {            if (checkTouchSlop(directions, i)) {                return true;            }        }        return false;    }    public boolean checkTouchSlop(int directions, int pointerId) {        if (!isPointerDown(pointerId)) {            return false;        }        final boolean checkHorizontal = (directions & DIRECTION_HORIZONTAL) == DIRECTION_HORIZONTAL;        final boolean checkVertical = (directions & DIRECTION_VERTICAL) == DIRECTION_VERTICAL;        final float dx = lastMotionX[pointerId] - initialMotionX[pointerId];        final float dy = lastMotionY[pointerId] - initialMotionY[pointerId];        if (checkHorizontal && checkVertical) {            return dx * dx + dy * dy > touchSlop * touchSlop;        } else if (checkHorizontal) {            return Math.abs(dx) > touchSlop;        } else if (checkVertical) {            return Math.abs(dy) > touchSlop;        }        return false;    }    public boolean isEdgeTouched(int edges) {        final int count = initialEdgesTouched.length;        for (int i = 0; i < count; i++) {            if (isEdgeTouched(edges, i)) {                return true;            }        }        return false;    }    public boolean isEdgeTouched(int edges, int pointerId) {        return isPointerDown(pointerId) && (initialEdgesTouched[pointerId] & edges) != 0;    }    public boolean isDragging() {        return dragState == STATE_DRAGGING;    }    private void releaseViewForPointerUp() {        velocityTracker.computeCurrentVelocity(1000, maxVelocity);        final float xvel = clampMag(VelocityTrackerCompat.getXVelocity(velocityTracker, activePointerId), minVelocity, maxVelocity);        final float yvel = clampMag(VelocityTrackerCompat.getYVelocity(velocityTracker, activePointerId), minVelocity, maxVelocity);        dispatchViewReleased(xvel, yvel);    }    private void dragTo(int left, int top, int dx, int dy) {        int clampedX = left;        int clampedY = top;        final int oldLeft = capturedView.getLeft();        final int oldTop = capturedView.getTop();        if (dx != 0) {            clampedX = callback.clampViewPositionHorizontal(capturedView, left, dx);            capturedView.offsetLeftAndRight(clampedX - oldLeft);        }        if (dy != 0) {            clampedY = callback.clampViewPositionVertical(capturedView, top, dy);            capturedView.offsetTopAndBottom(clampedY - oldTop);        }        if (dx != 0 || dy != 0) {            final int clampedDx = clampedX - oldLeft;            final int clampedDy = clampedY - oldTop;            callback.onViewPositionChanged(capturedView, clampedX, clampedY, clampedDx, clampedDy);        }    }    public boolean isCapturedViewUnder(int x, int y) {        return isViewUnder(capturedView, x, y);    }    public boolean isViewUnder(View view, int x, int y) {        if (view == null) {            return false;        }        return x >= view.getLeft() && x < view.getRight() && y >= view.getTop() && y < view.getBottom();    }    public View findTopChildUnder(int x, int y) {        final int childCount = viewGroup.getChildCount();        for (int i = childCount - 1; i >= 0; i--) {            final View child = viewGroup.getChildAt(callback.getOrderedChildIndex(i));            if (x >= child.getLeft() && x < child.getRight() && y >= child.getTop() && y < child.getBottom()) {                return child;            }        }        return null;    }    private int getEdgesTouched(int x, int y) {        int result = 0;        if (x < viewGroup.getLeft() + edgeSize) result |= EDGE_LEFT;        if (y < viewGroup.getTop() + edgeSize) result |= EDGE_TOP;        if (x > viewGroup.getRight() - edgeSize) result |= EDGE_RIGHT;        if (y > viewGroup.getBottom() - edgeSize) result |= EDGE_BOTTOM;        return result;    }}