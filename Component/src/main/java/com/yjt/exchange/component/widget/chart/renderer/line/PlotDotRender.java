package com.hynet.heebit.components.widget.chart.renderer.line;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Paint.Style;import android.graphics.Path;import android.graphics.RectF;import com.hynet.heebit.components.widget.chart.constant.DotStyle;import com.hynet.heebit.components.widget.chart.utils.MathUtil;public class PlotDotRender {    private static PlotDotRender plotDotRender = null;    protected Paint fillPaint = null;    private Path path = null;    private RectF rectF = new RectF();    public PlotDotRender() {    }    public static synchronized PlotDotRender getInstance() {        if (plotDotRender == null) {            plotDotRender = new PlotDotRender();        }        return plotDotRender;    }    public static void releaseInstance() {        if (plotDotRender != null) {            plotDotRender = null;        }    }    private void initializePath() {        if (null == path) {            path = new Path();        } else {            path.reset();        }    }    /**     * 开放填充内部环形的画笔     */    public Paint getInnerFillPaint() {        if (null == fillPaint) {            fillPaint = new Paint();            fillPaint.setColor(Color.WHITE);            fillPaint.setStyle(Style.FILL);            fillPaint.setAntiAlias(true);        }        return fillPaint;    }    /**     * 绘制线上的坐标点     *     * @param canvas  画布     * @param plotDot 点类型     * @param cirX    x坐标     * @param cirY    Y坐标     * @param paint   画笔     */    public RectF renderDot(Canvas canvas, PlotDot plotDot, float cirX, float cirY, Paint paint) {        float radius = plotDot.getDotRadius();        if (Float.compare(radius, 0.0f) == 0 || Float.compare(radius, 0.0f) == -1) {            return new RectF(0.0f, 0.0f, 0.0f, 0.0f);        }        float left = cirX - radius;        float top = cirY - radius;        float right = cirX + radius;        float bottom = cirY + radius;        if (DotStyle.DOT == plotDot.getDotStyle() || DotStyle.RING == plotDot.getDotStyle() || DotStyle.X == plotDot.getDotStyle()) {            rectF.left = left;            rectF.top = top;            rectF.right = right;            rectF.bottom = bottom;        }        switch (plotDot.getDotStyle()) {            case DOT:                canvas.drawCircle(cirX, cirY, radius, paint);                break;            case RING:                renderRing(canvas, paint, radius, plotDot, cirX, cirY);                break;            case RING2:                renderRing2(canvas, paint, radius, plotDot, cirX, cirY);                break;            case TRIANGLE: // 等腰三角形                renderTriangle(canvas, paint, radius, cirX, cirY);                break;            case PRISMATIC: // 棱形 Prismatic                //renderPrismatic(canvas,paint,radius,right,bottom,left );                       renderPrismatic(canvas, paint, radius, cirX, cirY);                break;            case RECT:                renderRect(canvas, paint, radius, cirX, cirY);                break;            case X:                renderX(canvas, paint);                break;            case CROSS:                renderCross(canvas, paint, radius, cirX, cirY);                break;            case HIDE:            default:        }        return rectF;    }    private void renderRing(Canvas canvas, Paint paint, float radius, PlotDot pDot, float cX, float bottom) {        float ringRadius = radius * 0.7f; // MathHelper.getInstance().mul(radius, 0.7f);        canvas.drawCircle(cX, bottom, radius, paint);        getInnerFillPaint().setColor(pDot.getRingInnerColor());        canvas.drawCircle(cX, bottom, ringRadius, getInnerFillPaint());    }    private void renderRing2(Canvas canvas, Paint paint, float radius, PlotDot pDot, float cX, float bottom) {        float ringRadius = radius * 0.7f; // MathHelper.getInstance().mul(radius, 0.7f);        canvas.drawCircle(cX, bottom, radius, paint);        getInnerFillPaint().setColor(pDot.getRingInnerColor());        canvas.drawCircle(cX, bottom, ringRadius, getInnerFillPaint());        ringRadius = radius * 0.3f;        getInnerFillPaint().setColor(pDot.getRing2InnerColor());        canvas.drawCircle(cX, bottom, ringRadius, getInnerFillPaint());    }    private void renderTriangle(Canvas canvas, Paint paint, float radius, float cirX, float cirY) {        float halfRadius = MathUtil.getInstance().div(radius, 2f);        float triganaleHeight = radius + radius / 2;        initializePath();        path.moveTo(cirX - radius, cirY + halfRadius);        path.lineTo(cirX, cirY - triganaleHeight);        path.lineTo(cirX + radius, cirY + halfRadius);        path.close();        canvas.drawPath(path, paint);        path.reset();        rectF.left = (cirX - radius);        rectF.top = (cirY - triganaleHeight);        rectF.right = (cirX + radius);        rectF.bottom = (cirY + halfRadius);    }    private void renderPrismatic(Canvas canvas, Paint paint, float radius, float cirX, float cirY) {        initializePath();        float left = cirX - radius;        float right = cirX + radius;        float centerX = left + (right - left) / 2;        float top = cirY - radius;        float bottom = cirY + radius;        path.moveTo(centerX, top);        path.lineTo(left, cirY);        path.lineTo(centerX, bottom);        path.lineTo(right, cirY);        path.lineTo(centerX, top);        path.close();        canvas.drawPath(path, paint);        path.reset();        rectF.left = left;        rectF.top = top;        rectF.right = right;        rectF.bottom = bottom;    }    private void renderRect(Canvas canvas, Paint paint, float radius, float cirX, float cirY) {        paint.setStyle(Style.FILL);        rectF.left = (cirX - radius);        rectF.top = (cirY - radius);        rectF.right = (cirX + radius);        rectF.bottom = (cirY + radius);        canvas.drawRect(rectF, paint);    }    private void renderX(Canvas canvas, Paint paint) {        canvas.drawLine(rectF.left, rectF.top, rectF.right, rectF.bottom, paint);        canvas.drawLine(rectF.left, rectF.bottom, rectF.right, rectF.top, paint);    }    private void renderCross(Canvas canvas, Paint paint, float radius, float cirX, float cirY) {        canvas.drawLine(cirX - radius, cirY, cirX + radius, cirY, paint);        canvas.drawLine(cirX, cirY - radius, cirX, cirY + radius, paint);    }}