package com.hynet.heebit.components.widget.chart.renderer.axis;import android.graphics.Canvas;import android.graphics.Paint.Align;import android.graphics.Path;import com.hynet.heebit.components.widget.chart.constant.AxisLineStyle;import com.hynet.heebit.components.widget.chart.constant.LabelLineFeed;import com.hynet.heebit.components.widget.chart.constant.OddEven;import com.hynet.heebit.components.widget.chart.constant.VerticalAlign;import com.hynet.heebit.components.widget.chart.utils.DrawUtil;import com.hynet.heebit.components.widget.chart.utils.IFormatterTextCallBack;import com.hynet.heebit.components.widget.chart.utils.MathUtil;import java.util.List;public class XYAxis extends Axis {    // 数据集    protected List<String> data = null;    // 用于格式化标签的回调接口    private IFormatterTextCallBack iFormatterTextCallBack;    //标签显示位置，分别在轴的左边，中间，右边    private Align tickMarksAlign = Align.RIGHT;    //标签显示位置，分别在轴的上面，中间，底下    private VerticalAlign tickMarksPosition = VerticalAlign.BOTTOM;    //默认刻度线所占宽度    private int tickMarksLength = 15;    //刻度标记与轴的间距    private int tickLabelMargin = 10;    protected boolean showAxisLineStyle = true;    private AxisLineStyle axisLineStyle = AxisLineStyle.NONE;    private float axisLineStyleWidth = 20.f;    private float axisLineStyleHeight = 30.f;    // 标签按哪种风格显示    protected LabelLineFeed labelLineFeed = LabelLineFeed.NORMAL;    public XYAxis() {        //设置轴线条粗细        //this.getAxisPaint().setStrokeWidth(5);    }    /**     * 设置时刻度显示在上，中，下哪个地方,针对横轴     *     * @param position 上方，居中，下方     */    public void setVerticalTickPosition(VerticalAlign position) {        tickMarksPosition = position;    }    /**     * 返回轴上刻度线显示的位置     *     * @return 位置     */    public VerticalAlign getVerticalTickPosition() {        return tickMarksPosition;    }    /**     * 设置刻度靠左，中，右哪个位置显示,针对竖轴     *     * @param align 靠左，居中，靠右     */    public void setHorizontalTickAlign(Align align) {        tickMarksAlign = align;    }    public Align getHorizontalTickAlign() {        return tickMarksAlign;    }    /**     * 设置标签的显示格式     *     * @param iFormatterTextCallBack 回调函数     */    public void setLabelFormatter(IFormatterTextCallBack iFormatterTextCallBack) {        this.iFormatterTextCallBack = iFormatterTextCallBack;    }    /**     * 返回标签显示格式     *     * @param text 传入当前值     *     * @return 显示格式     */    protected String getFormatterLabel(String text) {        String itemLabel;        try {            itemLabel = iFormatterTextCallBack.textFormatter(text);        } catch (Exception ex) {            itemLabel = text;        }        return itemLabel;    }    /**     * 设置横轴标签换行方式     * NORMAL: 不换行 <br\>     * ODD_EVEN: 奇数位置标签先换行 <br/>     * EVEN_ODD：偶数位置标签先换行     *     * @param labelLineFeed     */    public void setLabelLineFeed(LabelLineFeed labelLineFeed) {        this.labelLineFeed = labelLineFeed;    }    /**     * 竖轴坐标标签，依左，中，右，决定标签横向显示在相对中心点的位置     *     * @param centerX 轴上中点X坐标     * @param centerY 轴上中点X坐标     * @param text    标签文本     */    protected void renderHorizontalTick(float chatLeft, float plotLeft, Canvas canvas, float centerX, float centerY, String text, float labelX, float labelY, boolean isTickVisible) {        if (!isShow()) return;        float marksStartX = centerX;        float markeStopX = centerX;        float labelStartX = labelX;        float labelStartY = labelY;        switch (getHorizontalTickAlign()) {            case LEFT: {                if (isShowTickMarks()) {                    marksStartX = MathUtil.getInstance().sub(centerX, getTickMarksLength());                    markeStopX = centerX;                }                if (this.isShowAxisLabels())                    labelStartX = MathUtil.getInstance().sub(marksStartX, getTickLabelMargin());                break;            }            case CENTER: {                if (isShowTickMarks()) {                    marksStartX = MathUtil.getInstance().sub(centerX, getTickMarksLength() / 2);                    markeStopX = MathUtil.getInstance().add(centerX, getTickMarksLength() / 2);                }                break;            }            case RIGHT:                if (isShowTickMarks()) {                    marksStartX = centerX;                    markeStopX = MathUtil.getInstance().add(centerX, getTickMarksLength());                }                if (this.isShowAxisLabels())                    labelStartX = MathUtil.getInstance().add(markeStopX, getTickLabelMargin());                break;            default:                break;        }        //横轴刻度线        if (isShowTickMarks() && isTickVisible) {            canvas.drawLine(marksStartX, centerY, MathUtil.getInstance().add(markeStopX, this.getAxisPaint().getStrokeWidth() / 2), centerY, getTickMarksPaint());        }        //标签        //  当标签文本太长时，可以考虑分成多行显示如果实在太长，则开发用...来自己处理        if (isShowAxisLabels()) {            renderHorizontalTickLabels(chatLeft, plotLeft, canvas, labelStartX, labelStartY, markeStopX, text);        }    }    //画标签    private void renderHorizontalTickLabels(float chatLeft, float plotLeft, Canvas canvas, float labelStartX, float labelStartY, float markeStopX, String text) {        float labelHeight = DrawUtil.getInstance().getPaintFontHeight(getTickLabelPaint());        float textHeight = labelHeight / 4;        //处理多行标签        if (Align.LEFT == getHorizontalTickAlign()) {            float width = 0.0f;            if (isShowTickMarks()) {                width = markeStopX - chatLeft;            } else {                width = MathUtil.getInstance().sub(plotLeft, chatLeft);            }            renderLeftAxisTickMaskLabel(canvas, labelStartX, labelStartY + textHeight, text, width);        } else {            DrawUtil.getInstance().drawRotateText(getFormatterLabel(text), labelStartX, labelStartY + textHeight, getTickLabelRotateAngle(), canvas, getTickLabelPaint());        }    }    /**     * 横轴坐标标签，决定标签显示在相对中心点的上方，中间还是底部位置     *     * @param centerX 轴上中点X坐标     * @param centerY 轴上中点Y坐标     * @param text    标签文本     */    protected void renderVerticalTick(Canvas canvas, float centerX, float centerY, String text, float labelX, float labelY, boolean isTickVisible, OddEven oddEven) {        if (!isShow()) return;        float marksStartY = centerY;        float marksStopY = centerY;        float labelsStartY = labelY;        switch (getVerticalTickPosition()) {            case TOP: {                if (isShowTickMarks()) {                    marksStartY = MathUtil.getInstance().sub(centerY, getTickMarksLength());                    marksStopY = centerY;                }                marksStartY = MathUtil.getInstance().sub(centerY, getTickMarksLength());                marksStopY = centerY;                break;            }            case MIDDLE: {                if (isShowTickMarks()) {                    marksStartY = MathUtil.getInstance().sub(centerY, getTickMarksLength() / 2);                    marksStopY = MathUtil.getInstance().add(centerY, getTickMarksLength() / 2);                }                break;            }            case BOTTOM:                if (isShowTickMarks()) {                    marksStartY = centerY;                    //marksStopY = Math.round(centerY + getTickMarksLength());                    marksStopY = MathUtil.getInstance().add(centerY, getTickMarksLength());                }                if (this.isShowAxisLabels()) {                    labelsStartY = marksStopY + getTickLabelMargin() + DrawUtil.getInstance().getPaintFontHeight(getTickLabelPaint()) / 3;                }                break;            default:                break;        }        if (isShowTickMarks() && isTickVisible) {            canvas.drawLine(centerX, MathUtil.getInstance().sub(marksStartY, getAxisPaint().getStrokeWidth() / 2), /*marksStartY - this.getAxisPaint().getStrokeWidth() / 2,*/ centerX, marksStopY, getTickMarksPaint());            //}        }        if (isShowAxisLabels()) {            float labelHeight = DrawUtil.getInstance().getPaintFontHeight(getTickLabelPaint());            float currY = labelsStartY;            if (this.labelLineFeed != LabelLineFeed.NORMAL) {                switch (this.labelLineFeed) {                    case ODD_EVEN:                        if (oddEven == OddEven.ODD) currY += labelHeight;                        break;                    case EVEN_ODD:                        if (oddEven == OddEven.EVEN) currY += labelHeight;                        break;                    case NORMAL:                        break;                }            }            //定制化显示格式            DrawUtil.getInstance().drawRotateText(getFormatterLabel(text), labelX, currY, /*labelsStartY,*/ getTickLabelRotateAngle(), canvas, getTickLabelPaint());        }    }    //只针对renderHorizontalTick()，处理标签文字太长，分多行显示的情况,    // 即只有在竖向图左轴，并且标签靠左显示时，才会处理这个问题    private void renderLeftAxisTickMaskLabel(Canvas canvas, float centerX, float centerY, String text, float width) {        if (!isShowAxisLabels()) return;        //格式化后的标签文本.          String label = getFormatterLabel(text);        //横向找宽度，竖向找高度，竖向的就不处理了。只搞横向多行的        double txtLength = DrawUtil.getInstance().getTextWidth(getTickLabelPaint(), label);        if (txtLength <= width) {            //标签绘制在一行中            DrawUtil.getInstance().drawRotateText(label, centerX, centerY, getTickLabelRotateAngle(), canvas, getTickLabelPaint());        } else {    //Multi line            float txtHeight = DrawUtil.getInstance().getPaintFontHeight(getTickLabelPaint());            float charWidth = 0.0f, totalWidth = 0.0f;            float renderY = centerY;            String data = null;            for (int i = 0; i < label.length(); i++) {                charWidth = DrawUtil.getInstance().getTextWidth(getTickLabelPaint(), label.substring(i, i + 1));                totalWidth = MathUtil.getInstance().add(totalWidth, charWidth);                if (Float.compare(totalWidth, width) == 1) {                    DrawUtil.getInstance().drawRotateText(data, centerX, renderY, getTickLabelRotateAngle(), canvas, getTickLabelPaint());                    totalWidth = charWidth;                    renderY = MathUtil.getInstance().add(renderY, txtHeight);                    data = label.substring(i, i + 1);                } else {                    data += label.substring(i, i + 1);                }            } //end for            if (data.length() > 0) {                DrawUtil.getInstance().drawRotateText(data, centerX, renderY, getTickLabelRotateAngle(), canvas, getTickLabelPaint());            }        } //end width if    }    /**     * 返回轴刻度线长度     *     * @return 刻度线长度     */    public int getTickMarksLength() {        return tickMarksLength;    }    /**     * 设置轴刻度线与标签间的间距     *     * @param margin 间距     */    public void setTickLabelMargin(int margin) {        tickLabelMargin = margin;    }    /**     * 返回轴刻度线与标签间的间距     *     * @return 间距     */    public int getTickLabelMargin() {        return tickLabelMargin;    }    /**     * 设置轴线上三角箭头属性     *     * @param width  箭头宽度     * @param hieght 箭头高度     */    public void setAxisLinxCapWH(float width, float hieght) {        axisLineStyleWidth = width;        axisLineStyleHeight = hieght;    }    /**     * 设置轴线风格     *     * @param style 风格     */    public void setAxisLineStyle(AxisLineStyle style) {        axisLineStyle = style;    }    //绘制轴线    protected void drawAxisLine(Canvas canvas, float startX, float startY, float stopX, float stopY) {        if (AxisLineStyle.CAP == axisLineStyle || AxisLineStyle.FILLCAP == axisLineStyle) {            float w = axisLineStyleWidth / 2;            float angleTop = 0.f;            float axisEnd = axisLineStyleHeight / 2;            Path path = new Path();            //竖轴            if (Float.compare(startY, stopY) != 0) {                angleTop = stopY - axisLineStyleHeight;                float angleLeftX = stopX - w;                float angleRightX = stopX + w;                axisEnd = angleTop + axisEnd;                if (AxisLineStyle.FILLCAP == axisLineStyle) {                    path.moveTo(angleLeftX, axisEnd);                    path.lineTo(stopX, angleTop);                    path.lineTo(angleRightX, axisEnd);                    path.close();                    canvas.drawPath(path, getAxisPaint());                    canvas.drawLine(startX, startY, stopX, axisEnd, this.getAxisPaint());                } else {                    canvas.drawLine(startX, startY, stopX, angleTop, this.getAxisPaint());                    canvas.drawLine(angleLeftX, axisEnd, stopX, angleTop, this.getAxisPaint());                    canvas.drawLine(angleRightX, axisEnd, stopX, angleTop, this.getAxisPaint());                }            } else {                angleTop = stopX + axisLineStyleHeight;                float angleTopY = stopY - w;                float angleBottom = stopY + w;                axisEnd = angleTop - axisEnd;                if (AxisLineStyle.FILLCAP == axisLineStyle) {                    path.moveTo(axisEnd, angleTopY);                    path.lineTo(angleTop, stopY);                    path.lineTo(axisEnd, angleBottom);                    path.close();                    canvas.drawPath(path, getAxisPaint());                    canvas.drawLine(startX, startY, axisEnd, stopY, this.getAxisPaint());                } else {                    canvas.drawLine(startX, startY, angleTop, stopY, this.getAxisPaint());                    canvas.drawLine(axisEnd, angleTopY, angleTop, stopY, this.getAxisPaint());                    canvas.drawLine(axisEnd, angleBottom, angleTop, stopY, this.getAxisPaint());                }            }        } else { //none            canvas.drawLine(startX, startY, stopX, stopY, this.getAxisPaint());        }    }}