package com.hynet.heebit.components.widget.badge;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Path;import android.graphics.PointF;import android.graphics.PorterDuff;import android.graphics.PorterDuffXfermode;import android.graphics.RectF;import android.graphics.drawable.Drawable;import android.os.Build;import android.text.TextPaint;import android.text.TextUtils;import android.util.AttributeSet;import android.view.Gravity;import android.view.MotionEvent;import android.view.View;import android.view.ViewGroup;import android.view.ViewParent;import android.widget.FrameLayout;import android.widget.RelativeLayout;import com.hynet.heebit.components.constant.Regex;import com.hynet.heebit.components.utils.MathUtil;import com.hynet.heebit.components.utils.ViewUtil;import com.hynet.heebit.components.widget.badge.listener.Badge;import com.hynet.heebit.components.widget.badge.listener.OnDragStateChangedListener;import java.util.ArrayList;import java.util.List;import androidx.annotation.Nullable;public class BadgeView extends View implements Badge {    protected int colorBackground;    protected int colorBackgroundBorder;    protected int colorBadgeText;    protected Drawable drawableBackground;    protected Bitmap bitmapClip;    protected boolean drawableBackgroundClip;    protected float backgroundBorderWidth;    protected float badgeSizeMultiple;    protected float badgeTextSize;    protected float badgePadding;    protected int badgeNumber;    protected String badgeText;    protected boolean draggable;    protected boolean dragging;    protected boolean exact;    protected boolean showShadow;    protected int badgeGravity;    protected float offsetX;    protected float offsetY;    protected float defalutRadius;    protected float finalDragDistance;    protected int dragQuadrant;    protected boolean dragOutOfRange;    protected RectF badgeTextRect;    protected RectF badgeBackgroundRect;    protected Path dragPath;    protected Paint.FontMetrics badgeTextFontMetrics;    protected PointF badgeCenter;    protected PointF dragCenter;    protected PointF rowBadgeCenter;    protected PointF controlPoint;    protected List<PointF> innertangentPoints;    protected View targetView;    protected int width;    protected int height;    protected TextPaint badgeTextPaint;    protected Paint badgeBackgroundPaint;    protected Paint badgeBackgroundBorderPaint;    protected BadgeAnimator badgeAnimator;    protected OnDragStateChangedListener onDragStateChangedListener;    protected ViewGroup viewGroup;    public BadgeView(Context context) {        this(context, null);    }    public BadgeView(Context context, @Nullable AttributeSet attrs) {        this(context, attrs, 0);    }    public BadgeView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        initialize();    }    private void initialize() {        setLayerType(View.LAYER_TYPE_SOFTWARE, null);        this.badgeTextRect = new RectF();        this.badgeBackgroundRect = new RectF();        this.dragPath = new Path();        this.badgeCenter = new PointF();        this.dragCenter = new PointF();        this.rowBadgeCenter = new PointF();        this.controlPoint = new PointF();        this.innertangentPoints = new ArrayList<>();        this.badgeTextPaint = new TextPaint();        this.badgeTextPaint.setAntiAlias(true);        this.badgeTextPaint.setSubpixelText(true);        this.badgeTextPaint.setFakeBoldText(true);        this.badgeTextPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));        this.badgeBackgroundPaint = new Paint();        this.badgeBackgroundPaint.setAntiAlias(true);        this.badgeBackgroundPaint.setStyle(Paint.Style.FILL);        this.badgeBackgroundBorderPaint = new Paint();        this.badgeBackgroundBorderPaint.setAntiAlias(true);        this.badgeBackgroundBorderPaint.setStyle(Paint.Style.STROKE);        this.colorBackground = 0xFFE84E40;        this.colorBadgeText = 0xFFFFFFFF;        this.badgeSizeMultiple = 1;        this.badgeTextSize = ViewUtil.Companion.getInstance().dp2px(getContext(), 11);        this.badgePadding = ViewUtil.Companion.getInstance().dp2px(getContext(), 5);        this.badgeNumber = 0;        this.badgeGravity = Gravity.END | Gravity.TOP;        this.offsetX = ViewUtil.Companion.getInstance().dp2px(getContext(), 1);        this.offsetY = ViewUtil.Companion.getInstance().dp2px(getContext(), 1);        this.finalDragDistance = ViewUtil.Companion.getInstance().dp2px(getContext(), 90);        this.showShadow = true;        this.drawableBackgroundClip = false;        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {            setTranslationZ(1000);        }    }    @Override    public Badge setBadgeNumber(int badgeNumber) {        this.badgeNumber = badgeNumber;        if (badgeNumber < 0) {            this.badgeText = Regex.NONE.getRegext();        } else if (badgeNumber > 99) {            this.badgeText = exact ? String.valueOf(badgeNumber) : "99+";        } else if (badgeNumber > 0 && badgeNumber <= 99) {            this.badgeText = String.valueOf(badgeNumber);        } else if (badgeNumber == 0) {            this.badgeText = null;        }        measureText();        invalidate();        return this;    }    @Override    public int getBadgeNumber() {        return badgeNumber;    }    @Override    public Badge setBadgeText(String badgeText) {        this.badgeText = badgeText;        this.badgeNumber = 1;        measureText();        invalidate();        return this;    }    @Override    public String getBadgeText() {        return badgeText;    }    @Override    public Badge setExactMode(boolean exact) {        this.exact = exact;        if (badgeNumber > 99) {            setBadgeNumber(badgeNumber);        }        return this;    }    @Override    public boolean isExactMode() {        return exact;    }    @Override    public Badge setShowShadow(boolean showShadow) {        this.showShadow = showShadow;        invalidate();        return this;    }    @Override    public boolean isShowShadow() {        return showShadow;    }    @Override    public Badge setBadgeSizeMultiple(int sizeMultiple) {        if (sizeMultiple != 0f) {            this.badgeSizeMultiple = sizeMultiple;        } else {            this.badgeSizeMultiple = 1f;        }        invalidate();        return this;    }    @Override    public Badge setBadgeBackgroundColor(int color) {        this.colorBackground = color;        if (colorBackground == Color.TRANSPARENT) {            badgeTextPaint.setXfermode(null);        } else {            badgeTextPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));        }        invalidate();        return this;    }    @Override    public Badge stroke(int color, float width, boolean isDpValue) {        this.colorBackgroundBorder = color;        this.backgroundBorderWidth = isDpValue ? ViewUtil.Companion.getInstance().dp2px(getContext(), width) : width;        invalidate();        return this;    }    @Override    public int getBadgeBackgroundColor() {        return colorBackground;    }    @Override    public Badge setBadgeBackground(Drawable drawable) {        return setBadgeBackground(drawable, false);    }    @Override    public Badge setBadgeBackground(Drawable drawable, boolean clip) {        this.drawableBackgroundClip = clip;        this.drawableBackground = drawable;        generateClipLayer();        invalidate();        return this;    }    @Override    public Drawable getBadgeBackground() {        return drawableBackground;    }    @Override    public Badge setBadgeTextColor(int color) {        this.colorBadgeText = color;        invalidate();        return this;    }    @Override    public int getBadgeTextColor() {        return colorBadgeText;    }    @Override    public Badge setBadgeTextSize(float size, boolean isSpValue) {        this.badgeTextSize = isSpValue ? ViewUtil.Companion.getInstance().dp2px(getContext(), size) : size;        measureText();        invalidate();        return this;    }    @Override    public float getBadgeTextSize(boolean isSpValue) {        return isSpValue ? ViewUtil.Companion.getInstance().px2dp(getContext(), badgeTextSize) : badgeTextSize;    }    @Override    public Badge setBadgePadding(float padding, boolean isDpValue) {        this.badgePadding = isDpValue ? ViewUtil.Companion.getInstance().dp2px(getContext(), padding) : padding;        generateClipLayer();        invalidate();        return this;    }    @Override    public float getBadgePadding(boolean isDpValue) {        return isDpValue ? ViewUtil.Companion.getInstance().px2dp(getContext(), badgePadding) : badgePadding;    }    @Override    public boolean isDraggable() {        return draggable;    }    @Override    public Badge setBadgeGravity(int gravity) {        if (gravity == (Gravity.START | Gravity.TOP) || gravity == (Gravity.END | Gravity.TOP) || gravity == (Gravity.START | Gravity.BOTTOM) || gravity == (Gravity.END | Gravity.BOTTOM) || gravity == (Gravity.CENTER) || gravity == (Gravity.CENTER | Gravity.TOP) || gravity == (Gravity.CENTER | Gravity.BOTTOM) || gravity == (Gravity.CENTER | Gravity.START) || gravity == (Gravity.CENTER | Gravity.END)) {            this.badgeGravity = gravity;            invalidate();        } else {            throw new IllegalStateException("only support Gravity.START | Gravity.TOP , Gravity.END | Gravity.TOP , Gravity.START | Gravity.BOTTOM , Gravity.END | Gravity.BOTTOM , Gravity.CENTER , Gravity.CENTER | Gravity.TOP , Gravity.CENTER | Gravity.BOTTOM ,Gravity.CENTER | Gravity.START , Gravity.CENTER | Gravity.END");        }        return this;    }    @Override    public int getBadgeGravity() {        return badgeGravity;    }    @Override    public Badge setOffset(float offset, boolean isDpValue) {        return setOffset(offset, offset, isDpValue);    }    @Override    public Badge setOffset(float offsetX, float offsetY, boolean isDpValue) {        this.offsetX = isDpValue ? ViewUtil.Companion.getInstance().dp2px(getContext(), offsetX) : offsetX;        this.offsetY = isDpValue ? ViewUtil.Companion.getInstance().dp2px(getContext(), offsetY) : offsetY;        invalidate();        return this;    }    @Override    public float getOffsetX(boolean isDpValue) {        return isDpValue ? ViewUtil.Companion.getInstance().px2dp(getContext(), offsetX) : offsetX;    }    @Override    public float getOffsetY(boolean isDpValue) {        return isDpValue ? ViewUtil.Companion.getInstance().px2dp(getContext(), offsetY) : offsetY;    }    @Override    public Badge setOnDragStateChangedListener(OnDragStateChangedListener onDragStateChangedListener) {        this.draggable = onDragStateChangedListener != null;        this.onDragStateChangedListener = onDragStateChangedListener;        return this;    }    @Override    public PointF getDragCenter() {        if (draggable && dragging) {            return dragCenter;        } else {            return null;        }    }    @Override    public Badge bindTarget(View view) {        if (view == null) {            throw new IllegalStateException("targetView can not be null");        }        if (getParent() != null) {            ((ViewGroup) getParent()).removeView(this);        }        ViewParent targetParent = view.getParent();        if (targetParent != null && targetParent instanceof ViewGroup) {            this.targetView = view;            if (targetParent instanceof BadgeContainer) {                ((BadgeContainer) targetParent).addView(this);            } else {                ViewGroup targetContainer = (ViewGroup) targetParent;                int index = targetContainer.indexOfChild(view);                ViewGroup.LayoutParams targetParams = view.getLayoutParams();                targetContainer.removeView(view);                final BadgeContainer badgeContainer = new BadgeContainer(getContext());                if (targetContainer instanceof RelativeLayout) {                    badgeContainer.setId(view.getId());                }                targetContainer.addView(badgeContainer, index, targetParams);                badgeContainer.addView(view);                badgeContainer.addView(this);            }        } else {            throw new IllegalStateException("targetView must have a parent");        }        return this;    }    @Override    public View getTargetView() {        return targetView;    }    @Override    public void hide(boolean animate) {        if (animate && viewGroup != null) {            initializeRowBadgeCenter();            animateHide(rowBadgeCenter);        } else {            setBadgeNumber(0);        }    }    @Override    protected void onAttachedToWindow() {        super.onAttachedToWindow();        if (viewGroup == null) {            findViewRoot(targetView);        }    }    private void findViewRoot(View view) {        this.viewGroup = (ViewGroup) view.getRootView();        if (viewGroup == null) {            findActivityRoot(view);        }    }    private void findActivityRoot(View view) {        if (view.getParent() != null && view.getParent() instanceof View) {            findActivityRoot((View) view.getParent());        } else if (view instanceof ViewGroup) {            this.viewGroup = (ViewGroup) view;        }    }    @Override    public boolean onTouchEvent(MotionEvent event) {        switch (event.getActionMasked()) {            case MotionEvent.ACTION_DOWN:            case MotionEvent.ACTION_POINTER_DOWN:                float x = event.getX();                float y = event.getY();                if (draggable && event.getPointerId(event.getActionIndex()) == 0 && (x > badgeBackgroundRect.left && x < badgeBackgroundRect.right && y > badgeBackgroundRect.top && y < badgeBackgroundRect.bottom) && badgeText != null) {                    initializeRowBadgeCenter();                    this.dragging = true;                    updateDragStateChangedListener(DragState.START);                    defalutRadius = ViewUtil.Companion.getInstance().dp2px(getContext(), 7);                    getParent().requestDisallowInterceptTouchEvent(true);                    screenFromWindow(true);                    dragCenter.x = event.getRawX();                    dragCenter.y = event.getRawY();                }                break;            case MotionEvent.ACTION_MOVE:                if (dragging) {                    dragCenter.x = event.getRawX();                    dragCenter.y = event.getRawY();                    invalidate();                }                break;            case MotionEvent.ACTION_UP:            case MotionEvent.ACTION_POINTER_UP:            case MotionEvent.ACTION_CANCEL:                if (event.getPointerId(event.getActionIndex()) == 0 && dragging) {                    dragging = false;                    if (dragOutOfRange) {                        animateHide(dragCenter);                        updateDragStateChangedListener(DragState.SUCCEED);                    } else {                        reset();                        updateDragStateChangedListener(DragState.CANCELED);                    }                }                break;        }        return dragging || super.onTouchEvent(event);    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        super.onSizeChanged(w, h, oldw, oldh);        this.width = w;        this.height = h;    }    @Override    protected void onDraw(Canvas canvas) {//        super.onDraw(canvas);        if (badgeAnimator != null && badgeAnimator.isRunning()) {            badgeAnimator.draw(canvas);            return;        }        if (badgeText != null) {            generateShadow(showShadow);            badgeBackgroundPaint.setColor(colorBackground);            badgeBackgroundBorderPaint.setColor(colorBackgroundBorder);            badgeBackgroundBorderPaint.setStrokeWidth(backgroundBorderWidth);            badgeTextPaint.setColor(colorBadgeText);            badgeTextPaint.setTextAlign(Paint.Align.CENTER);            float badgeRadius = getBadgeCircleRadius();            float startCircleRadius = defalutRadius * (1 - MathUtil.Companion.getInstance().getPointDistance(rowBadgeCenter, dragCenter) / finalDragDistance);            if (draggable && dragging) {                dragQuadrant = MathUtil.Companion.getInstance().getQuadrant(dragCenter, rowBadgeCenter);                generateShadow(showShadow);                if (dragOutOfRange = startCircleRadius < ViewUtil.Companion.getInstance().dp2px(getContext(), 1.5f)) {                    updateDragStateChangedListener(DragState.DRAGGING_OUT_OF_RANGE);                    drawBadge(canvas, dragCenter, badgeRadius);                } else {                    updateDragStateChangedListener(DragState.DRAGGING);                    drawDragging(canvas, startCircleRadius, badgeRadius);                    drawBadge(canvas, dragCenter, badgeRadius);                }            } else {                findBadgeCenter();                drawBadge(canvas, badgeCenter, badgeRadius);            }        }    }    private void drawDragging(Canvas canvas, float startRadius, float badgeRadius) {        float dy = dragCenter.y - rowBadgeCenter.y;        float dx = dragCenter.x - rowBadgeCenter.x;        innertangentPoints.clear();        if (dx != 0) {            double k1 = dy / dx;            double k2 = -1 / k1;            MathUtil.Companion.getInstance().getInnertangentPoints(dragCenter, badgeRadius, k2, innertangentPoints);            MathUtil.Companion.getInstance().getInnertangentPoints(rowBadgeCenter, startRadius, k2, innertangentPoints);        } else {            MathUtil.Companion.getInstance().getInnertangentPoints(dragCenter, badgeRadius, 0d, innertangentPoints);            MathUtil.Companion.getInstance().getInnertangentPoints(rowBadgeCenter, startRadius, 0d, innertangentPoints);        }        dragPath.reset();        dragPath.addCircle(rowBadgeCenter.x, rowBadgeCenter.y, startRadius, dragQuadrant == 1 || dragQuadrant == 2 ? Path.Direction.CCW : Path.Direction.CW);        controlPoint.x = (rowBadgeCenter.x + dragCenter.x) / 2.0f;        controlPoint.y = (rowBadgeCenter.y + dragCenter.y) / 2.0f;        dragPath.moveTo(innertangentPoints.get(2).x, innertangentPoints.get(2).y);        dragPath.quadTo(controlPoint.x, controlPoint.y, innertangentPoints.get(0).x, innertangentPoints.get(0).y);        dragPath.lineTo(innertangentPoints.get(1).x, innertangentPoints.get(1).y);        dragPath.quadTo(controlPoint.x, controlPoint.y, innertangentPoints.get(3).x, innertangentPoints.get(3).y);        dragPath.lineTo(innertangentPoints.get(2).x, innertangentPoints.get(2).y);        dragPath.close();        canvas.drawPath(dragPath, badgeBackgroundPaint);        //draw dragging border        if (colorBackgroundBorder != 0 && backgroundBorderWidth > 0) {            dragPath.reset();            dragPath.moveTo(innertangentPoints.get(2).x, innertangentPoints.get(2).y);            dragPath.quadTo(controlPoint.x, controlPoint.y, innertangentPoints.get(0).x, innertangentPoints.get(0).y);            dragPath.moveTo(innertangentPoints.get(1).x, innertangentPoints.get(1).y);            dragPath.quadTo(controlPoint.x, controlPoint.y, innertangentPoints.get(3).x, innertangentPoints.get(3).y);            float startY;            float startX;            if (dragQuadrant == 1 || dragQuadrant == 2) {                startX = innertangentPoints.get(2).x - rowBadgeCenter.x;                startY = rowBadgeCenter.y - innertangentPoints.get(2).y;            } else {                startX = innertangentPoints.get(3).x - rowBadgeCenter.x;                startY = rowBadgeCenter.y - innertangentPoints.get(3).y;            }            float startAngle = 360 - (float) MathUtil.Companion.getInstance().radianToAngle(MathUtil.Companion.getInstance().getTanRadian(Math.atan(startY / startX), dragQuadrant - 1 == 0 ? 4 : dragQuadrant - 1));            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {                dragPath.addArc(rowBadgeCenter.x - startRadius, rowBadgeCenter.y - startRadius, rowBadgeCenter.x + startRadius, rowBadgeCenter.y + startRadius, startAngle, 180);            } else {                dragPath.addArc(new RectF(rowBadgeCenter.x - startRadius, rowBadgeCenter.y - startRadius, rowBadgeCenter.x + startRadius, rowBadgeCenter.y + startRadius), startAngle, 180);            }            canvas.drawPath(dragPath, badgeBackgroundBorderPaint);        }    }    private void findBadgeCenter() {        float rectWidth = badgeTextRect.height() > badgeTextRect.width() ? badgeTextRect.height() : badgeTextRect.width();        switch (badgeGravity) {            case Gravity.START | Gravity.TOP:                badgeCenter.x = offsetX + badgePadding + rectWidth / 2f;                badgeCenter.y = offsetY + badgePadding + badgeTextRect.height() / 2f;                break;            case Gravity.START | Gravity.BOTTOM:                badgeCenter.x = offsetX + badgePadding + rectWidth / 2f;                badgeCenter.y = height - (offsetY + badgePadding + badgeTextRect.height() / 2f);                break;            case Gravity.END | Gravity.TOP:                badgeCenter.x = width - (offsetX + badgePadding + rectWidth / 2f);                badgeCenter.y = offsetY + badgePadding + badgeTextRect.height() / 2f;                break;            case Gravity.END | Gravity.BOTTOM:                badgeCenter.x = width - (offsetX + badgePadding + rectWidth / 2f);                badgeCenter.y = height - (offsetY + badgePadding + badgeTextRect.height() / 2f);                break;            case Gravity.CENTER:                badgeCenter.x = width / 2f;                badgeCenter.y = height / 2f;                break;            case Gravity.CENTER | Gravity.TOP:                badgeCenter.x = width / 2f;                badgeCenter.y = offsetY + badgePadding + badgeTextRect.height() / 2f;                break;            case Gravity.CENTER | Gravity.BOTTOM:                badgeCenter.x = width / 2f;                badgeCenter.y = height - (offsetY + badgePadding + badgeTextRect.height() / 2f);                break;            case Gravity.CENTER | Gravity.START:                badgeCenter.x = offsetX + badgePadding + rectWidth / 2f;                badgeCenter.y = height / 2f;                break;            case Gravity.CENTER | Gravity.END:                badgeCenter.x = width - (offsetX + badgePadding + rectWidth / 2f);                badgeCenter.y = height / 2f;                break;        }        initializeRowBadgeCenter();    }    protected void screenFromWindow(boolean screen) {        if (getParent() != null) {            ((ViewGroup) getParent()).removeView(this);        }        if (screen) {            viewGroup.addView(this, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));        } else {            bindTarget(targetView);        }    }    protected void animateHide(PointF center) {        if (badgeText == null) {            return;        }        if (badgeAnimator == null || !badgeAnimator.isRunning()) {            screenFromWindow(true);            this.badgeAnimator = new BadgeAnimator(createBadgeBitmap(), center, this);            badgeAnimator.start();            setBadgeNumber(0);        }    }    private void initializeRowBadgeCenter() {        int[] screenPoint = new int[2];        getLocationOnScreen(screenPoint);        rowBadgeCenter.x = badgeCenter.x + screenPoint[0];        rowBadgeCenter.y = badgeCenter.y + screenPoint[1];    }    private void updateDragStateChangedListener(int state) {        if (onDragStateChangedListener != null)            onDragStateChangedListener.onDragStateChanged(state, this, targetView);    }    private void drawBadge(Canvas canvas, PointF center, float radius) {        if (center.x == -1000 && center.y == -1000) {            return;        }        if (badgeText.isEmpty() || badgeText.length() == 1) {            badgeBackgroundRect.left = center.x - (int) radius;            badgeBackgroundRect.top = center.y - (int) radius;            badgeBackgroundRect.right = center.x + (int) radius;            badgeBackgroundRect.bottom = center.y + (int) radius;            if (drawableBackground != null) {                drawBadgeBackground(canvas);            } else {                canvas.drawCircle(center.x, center.y, radius * badgeSizeMultiple, badgeBackgroundPaint);                if (colorBackgroundBorder != 0 && backgroundBorderWidth > 0) {                    canvas.drawCircle(center.x, center.y, radius, badgeBackgroundBorderPaint);                }            }        } else {            badgeBackgroundRect.left = center.x - (badgeTextRect.width() / 2f + badgePadding);            badgeBackgroundRect.top = center.y - (badgeTextRect.height() / 2f + badgePadding * 0.5f);            badgeBackgroundRect.right = center.x + (badgeTextRect.width() / 2f + badgePadding);            badgeBackgroundRect.bottom = center.y + (badgeTextRect.height() / 2f + badgePadding * 0.5f);            radius = badgeBackgroundRect.height() / 2f;            if (drawableBackground != null) {                drawBadgeBackground(canvas);            } else {                canvas.drawRoundRect(badgeBackgroundRect, radius, radius, badgeBackgroundPaint);                if (colorBackgroundBorder != 0 && backgroundBorderWidth > 0) {                    canvas.drawRoundRect(badgeBackgroundRect, radius, radius, badgeBackgroundBorderPaint);                }            }        }        if (!badgeText.isEmpty()) {            canvas.drawText(badgeText, center.x, (badgeBackgroundRect.bottom + badgeBackgroundRect.top - badgeTextFontMetrics.bottom - badgeTextFontMetrics.top) / 2f, badgeTextPaint);        }    }    protected Bitmap createBadgeBitmap() {        Bitmap bitmap = Bitmap.createBitmap((int) badgeBackgroundRect.width() + ViewUtil.Companion.getInstance().dp2px(getContext(), 3), (int) badgeBackgroundRect.height() + ViewUtil.Companion.getInstance().dp2px(getContext(), 3), Bitmap.Config.ARGB_8888);        Canvas canvas = new Canvas(bitmap);        drawBadge(canvas, new PointF(canvas.getWidth() / 2f, canvas.getHeight() / 2f), getBadgeCircleRadius());        return bitmap;    }    private void drawBadgeBackground(Canvas canvas) {        badgeBackgroundPaint.setShadowLayer(0, 0, 0, 0);        int left = (int) badgeBackgroundRect.left;        int top = (int) badgeBackgroundRect.top;        int right = (int) badgeBackgroundRect.right;        int bottom = (int) badgeBackgroundRect.bottom;        if (drawableBackgroundClip) {            right = left + bitmapClip.getWidth();            bottom = top + bitmapClip.getHeight();            canvas.saveLayer(left, top, right, bottom, null, Canvas.ALL_SAVE_FLAG);        }        drawableBackground.setBounds(left, top, right, bottom);        drawableBackground.draw(canvas);        if (drawableBackgroundClip) {            badgeBackgroundPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));            canvas.drawBitmap(bitmapClip, left, top, badgeBackgroundPaint);            canvas.restore();            badgeBackgroundPaint.setXfermode(null);            if (badgeText.isEmpty() || badgeText.length() == 1) {                canvas.drawCircle(badgeBackgroundRect.centerX(), badgeBackgroundRect.centerY(), badgeBackgroundRect.width() / 2f, badgeBackgroundBorderPaint);            } else {                canvas.drawRoundRect(badgeBackgroundRect, badgeBackgroundRect.height() / 2, badgeBackgroundRect.height() / 2, badgeBackgroundBorderPaint);            }        } else {            canvas.drawRect(badgeBackgroundRect, badgeBackgroundBorderPaint);        }    }    private float getBadgeCircleRadius() {        if (badgeText.isEmpty()) {            return badgePadding;        } else if (badgeText.length() == 1) {            return badgeTextRect.height() > badgeTextRect.width() ? badgeTextRect.height() / 2f + badgePadding * 0.5f : badgeTextRect.width() / 2f + badgePadding * 0.5f;        } else {            return badgeBackgroundRect.height() / 2f;        }    }    private void generateShadow(boolean showShadow) {        int x = ViewUtil.Companion.getInstance().dp2px(getContext(), 1);        int y = ViewUtil.Companion.getInstance().dp2px(getContext(), 1.5f);        switch (dragQuadrant) {            case 1:                x = ViewUtil.Companion.getInstance().dp2px(getContext(), 1);                y = ViewUtil.Companion.getInstance().dp2px(getContext(), -1.5f);                break;            case 2:                x = ViewUtil.Companion.getInstance().dp2px(getContext(), -1);                y = ViewUtil.Companion.getInstance().dp2px(getContext(), -1.5f);                break;            case 3:                x = ViewUtil.Companion.getInstance().dp2px(getContext(), -1);                y = ViewUtil.Companion.getInstance().dp2px(getContext(), 1.5f);                break;            case 4:                x = ViewUtil.Companion.getInstance().dp2px(getContext(), 1);                y = ViewUtil.Companion.getInstance().dp2px(getContext(), 1.5f);                break;        }        badgeBackgroundPaint.setShadowLayer(showShadow ? ViewUtil.Companion.getInstance().dp2px(getContext(), 2f) : 0, x, y, 0x33000000);    }    private void measureText() {        badgeTextRect.left = 0;        badgeTextRect.top = 0;        if (TextUtils.isEmpty(badgeText)) {            badgeTextRect.right = 0;            badgeTextRect.bottom = 0;        } else {            badgeTextPaint.setTextSize(badgeTextSize);            badgeTextRect.right = badgeTextPaint.measureText(badgeText);            badgeTextFontMetrics = badgeTextPaint.getFontMetrics();            badgeTextRect.bottom = badgeTextFontMetrics.descent - badgeTextFontMetrics.ascent;        }        generateClipLayer();    }    private void generateClipLayer() {        if (badgeText == null) {            return;        }        if (!drawableBackgroundClip) {            return;        }        if (bitmapClip != null && !bitmapClip.isRecycled()) {            bitmapClip.recycle();        }        float radius = getBadgeCircleRadius();        if (badgeText.isEmpty() || badgeText.length() == 1) {            bitmapClip = Bitmap.createBitmap((int) radius * 2, (int) radius * 2, Bitmap.Config.ARGB_4444);            Canvas srcCanvas = new Canvas(bitmapClip);            srcCanvas.drawCircle(srcCanvas.getWidth() / 2f, srcCanvas.getHeight() / 2f, srcCanvas.getWidth() / 2f, badgeBackgroundPaint);        } else {            bitmapClip = Bitmap.createBitmap((int) (badgeTextRect.width() + badgePadding * 2), (int) (badgeTextRect.height() + badgePadding), Bitmap.Config.ARGB_4444);            Canvas srcCanvas = new Canvas(bitmapClip);            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {                srcCanvas.drawRoundRect(0, 0, srcCanvas.getWidth(), srcCanvas.getHeight(), srcCanvas.getHeight() / 2f, srcCanvas.getHeight() / 2f, badgeBackgroundPaint);            } else {                srcCanvas.drawRoundRect(new RectF(0, 0, srcCanvas.getWidth(), srcCanvas.getHeight()), srcCanvas.getHeight() / 2f, srcCanvas.getHeight() / 2f, badgeBackgroundPaint);            }        }    }    public void reset() {        dragCenter.x = -1000;        dragCenter.y = -1000;        dragQuadrant = 4;        screenFromWindow(false);        getParent().requestDisallowInterceptTouchEvent(false);        invalidate();    }}